---
title: "`scfind` package vignette"
author: "Vladimir Kiselev and Jimmy Tsz Hang Lee"
date: "`r Sys.Date()`"
output:
    BiocStyle::html_document:
        toc: true
vignette: >
  %\VignetteIndexEntry{`scfind` package vignette}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r knitr-options, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
library("knitr")
opts_chunk$set(fig.align = 'center', fig.width = 6, fig.height = 5, dev = 'png')
op <- options(gvis.plot.tag='chart')
```

# Introduction

The number of cell atlases is growing rapidly, as a result of advances in single-cell sequencing techniques and cheaper sequencing cost. To search through these large single-cell datasets for analysis, however, is time-consuming and inefficient because these types of dataset usually take up large amounts of memory. `scfind` has adopted an efficient compression strategy which makes it suitable for real-time queries of millions of cells.

`scfind` is a method for searching specific cell types from large single-cell datasets by a query of gene list, in which `scfind` can suggest subquries score by TF-IDF method. `scfind` can perform hypergeometric test which allows the evaluation of marker genes specific to each cell type within a dataset. A manuscript describing `scfind` in details is available in [bioRxiv](https://doi.org/10.1101/788596)

# `SingleCellExperiment` class

If you already have an `SingleCellExperiment` object, then proceed to the next chapter.

`scfind` is built on top of the Bioconductorâ€™s [SingleCellExperiment](https://bioconductor.org/packages/SingleCellExperiment) class. `scfind` operates on objects of class `SingleCellExperiment` and writes all of its results back to an object. Please read corresponding vignettes on how to create a `SingleCellExperiment` from your own data. For illustrative purposes, a list of `SingleCellExperiment` objects of the `Tabula Muris (FACS)` and the `Tabula Muris (10X)` datasets are provided. The investigators ([The Tabula Muris Consortium](https://doi.org/10.1038/s41586-018-0590-4)) have profiled almost every cell-type in the mouse using high-coverage FACS-sorted cells + Smartseq2. in the original publication. We will combine the indices of 18 tissues into a super-index.

```{r}
# List of `Tabula Muris (FACS)` `SingleCellExperiment` objects
data(tmfacs)
# List of `Tabula Muris (10X)` `SingleCellExperiment` objects
data(tm10x)

library("scfind")
suppressPackageStartupMessages(library("SingleCellExperiment"))

# Download and load `SingleCellExperiment` object of the `Heart` dataset
sce.heart <- readRDS(url(grep("Heart", tmfacs, value = T)))

sce.heart

colData(sce.heart)
```


# `scfind` Input

## Index

Once we have a `SingleCellExperiment` object, we can run `scfind`. Firstly, we need to build the `scfind` index from our input dataset.

By default `scfind` uses the `cell_type1` column of the `colData` slot in the reference to identify cell type names. 

```{r}
scfind.index <- buildCellTypeIndex(sce = sce.heart, 
                             cell.type.label = "cell_type1", # If you have your own clustering result or manually defined groups, you may change this parameters with the corresponding column name of the `colData`
                             dataset.name = "Heart", 
                             assay.name = "counts")

# if the dataset contains more than one category, users can build index for each tissue individually and merge all indices into 1 super-index using `mergeDataset` as following:
sce.thymus <- readRDS(url(grep("Thymus", tmfacs, value = T)))

scfind.index.new <- buildCellTypeIndex(sce = sce.thymus, 
                             cell.type.label = "cell_type1", # If you have your own clustering result or manually defined groups, you may change this parameters with the corresponding column name of the `colData`
                             dataset.name = "Thymus", 
                             assay.name = "counts")

merged.index <- mergeDataset(scfind.index, scfind.index.new)
merged.index
```

```{r eval=FALSE, include=FALSE}
# The `scfind` index can be saved as a RDS object 
saveObject(object = merged.index, 
           file = "scfindIndex.rds")
```

# Cell Type Search

Once the `scfind` index is built, one can view all existing genes in the datasets using `scfindGenes`

```{r}
sample(scfindGenes(merged.index), 20)
```

or view all existing cell type names in the database using `cellTypeNames`

```{r}
cellTypeNames(merged.index)

# To specify the dataset
cellTypeNames(merged.index, "Thymus")
```


## Evaluate Marker Genes

Once we have a `scfind` index, we can find the cell types that most likely represent your gene set from your dataset very quickly:
For illustrative purposes, we will use a preprocessed scfind index of the `Tabula Muris (FACS)`. 
```{r eval=FALSE, include=FALSE}
# `scfind` index of the `Tabula Muris (FACS)` dataset
data(ExampleIndex_TabulaMurisFACS)

# `scfind` index of the `Tabula Muris (10X)` dataset
data(ExampleIndex_TabulaMuris10X)

geneIndex <- loadObject(file = url(ExampleIndex_TabulaMurisFACS))

# try `geneIndex <- loadObject(file = url(ExampleIndex_TabulaMuris10X))` for another Tabula Muris Dataset

geneIndex@datasets
```

`scfind` is a search engine for single cell datasets.  The central operation carried out by `scfind` is to identify the set of cells that express a set of genes or peaks (i.e. the query) specified by the user.
```{r}
query <- c("Il2ra", "Ptprc", "Il7r", "Ctla4")

# The p-values is calculated by hypergeometric test
hyperQueryCellTypes(object = geneIndex, 
                    gene.list = query)

# Use the `datasets` argument to specify the datasets
result <- hyperQueryCellTypes(object = geneIndex,
                    gene.list = query,
                    datasets = c("Marrow", "Thymus", "Fat"))

# The calculation shows that the query gene set is specific for the `Marrow.T cell` cell type with the lowest p-value.
barplot(-log10(result$pval), ylab = "-log10(pval)", las = 2, names.arg = result$cell_type)
```

To allow search of enriched cell type from a long list of gene query, `scfind` features a query optimization routin. First, the function `markerGenes` will counter suggest subqueries with the highest support in the dataset. The TF-IDF score for each gene set allows user to identify the best subquery for finding the most relevant cell type. We will use the marker genes identified in an original publication Yanbin et al. 2015. Cardiomyocyte-specific markers used in immunostaining.
```{r}
long.query <- c("Mef2c", "Gata4", "Nkx2.5", "Myh6", "tnnt2", "tnni3", "CDH2", "Cx43", "GJA1")

# In which, `scfind` will suggest subqueries for the initial gene sets along with number of cells and cell types that express the genes
result <- markerGenes(object = geneIndex,
                      gene.list = long.query)

result

barplot(result$tfidf, main = "TF-IDF score", names.arg = as.character(result$Query), ylab="TF-IDF score", cex.names = 0.65, las = 2)
barplot(result$Cells, main = "No. of cells", names.arg = as.character(result$Query), ylab="no. of cells", cex.names = 0.65, las = 2)
```

By ranking the tfidf score, the best subquery can be used to search for cell types that is enriched. 
```{r}
bestQuery <- strsplit(as.character(result$Query[tail(order(result$Genes),1)]), ',')[[1]]
bestQuery

# The calculation above shows that a list of genes containing `Cdh2`, `Gata4`, `Gja1`, `Mef2c`, `Myh6`, `Tnni3` and `Tnnt2` is specific for the `Heart.cardiac muscle cell` cell type with the lowest p-value.
enrichedCellTypes <- hyperQueryCellTypes(object = geneIndex, 
                                         gene.list = bestQuery)
enrichedCellTypes
```

To further evaluate a specific query by calculating the precision recall metrics
```{r}
evaluateGenes <- evaluateMarkers(object = geneIndex, 
                                 gene.list = bestQuery, 
                                 cell.types = "Heart.cardiac muscle cell")
evaluateGenes

data1 <- t(evaluateGenes[, c(7,6,8)])

colnames(data1) <- evaluateGenes$genes

barplot(data1 , 
        main = paste("Evaluation of markers in Heart.cardiac muscle cell"), 
        beside = T, 
        legend = rownames(data1), 
        ylab=  "Arbitrary unit", 
        ylim = c(0, 1.1))
```

# Marker Gene Search

If one is more interested in finding out which marker genes best represent a cell type in the dataset, `cellTypeMarkers` function should be used for searching the index:
```{r}
interestedCellType <- c("Kidney.leukocyte")

findMarkers <- cellTypeMarkers(object = geneIndex, 
                               cell.types = interestedCellType)

data2 <- t(findMarkers[, c(7,6,8)])

colnames(data2) <- findMarkers$genes

barplot(data2 , 
        main = paste("Marker genes of ", interestedCellType), 
        font.axis = 1, 
        beside = T, 
        legend = rownames(data2), 
        ylab = "Arbitrary unit", 
        ylim = c(0, 1.1))

# You can also specify the background cell types

findMarkers <- cellTypeMarkers(object = geneIndex, 
                               cell.types = interestedCellType,
                               background.cell.types = cellTypeNames(object = geneIndex,
                                                                     datasets = "Kidney"))

data3 <- t(findMarkers[, c(7,6,8)])

colnames(data3) <- findMarkers$genes

barplot(data3 , 
        main = paste("Marker genes of ", interestedCellType), 
        font.axis = 1, 
        beside = T, 
        legend = rownames(data2), 
        ylab = "Arbitrary unit", 
        ylim = c(0, 1.1))
```

# Interactive Session
__Note__ `scfind` can also be run in an interactive `Shiny` session:
```{r}
scfindShiny(object = geneIndex)
```
To enhancer user experience, the [Hemberg-lab](https://scfind.sanger.ac.uk/) has an interactive website of 9 collections of `scfind` indexes.


# sessionInfo()

```{r echo=FALSE}
sessionInfo()
```

